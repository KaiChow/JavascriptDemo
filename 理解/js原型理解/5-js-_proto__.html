<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>js-_proto__</title>
  </head>
  <body>
    <script>
      /**
       * 1,实例对象.__proto__ = 创建自己的构造函数内部的prototype（原型对象）
       * 2,实例对象.__proto__.constructor = 创建自己的构造函数
       */

      function Person() {}

      var person1 = new Person()
      var person2 = new Person()

      console.log(person1.__proto__.constructor) //Person() {}

      console.log(person1.__proto__) //{constructor: ƒ}

      console.log(Person.prototype) //{constructor: ƒ}

      /**
       *
       *
       * 总结一下：
       * 我们需要牢记两点：
       * 1,__proto__和constructor属性是对象所独有的；
       * 2, prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。__proto__属性的作用就是当访问一个对象的属性时，如果该
       * 对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，直到__proto__属性的终点null，再往上找就相当于在null上取值会
       * 报错。通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。
       * 3,prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。
       * 4,constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。
       */

      /**
       *
       * 1. 单从constructor属性来讲，只有prototype对象才有这个属性，而其它对象的constructor属性都是通过__proto__对象从prototype继承而来。2. 函数在创建时，JS会为该函数创建一个对应的prototype对象，而这个prototype对象的constructor属性又指向该函数，即Foo.prototype.constructor === Foo
       */
    </script>
  </body>
</html>
